import datetime
import numpy as np
from scipy import ndimage
import os

import cv2
import easygui as eg
import openpyxl

# additional packages
import pandas as pd
from math import ceil
import copy
import matplotlib.pyplot as plt

import spot_position_func as spf
import constants as cs


# pred_xrv4000 = cs.pred_xrv4000
# pred_xrv3000 = cs.pred_xrv3000

class ActiveScript:
    def __init__(self, image_dir):
        actscr_loc = os.path.join(os.path.dirname(image_dir),
                                  'activescript.txt')
        for line in open(actscr_loc, 'r'):
            if line.startswith('CameraHRa'):
                CameraHRatio = float(line.split("=")[1].strip())
            if line.startswith('CameraVRa'):
                CameraVRatio = float(line.split("=")[1].strip())
            if line.startswith('AppXCenter'):
                AppXCenter = float(line.split("=")[1].strip())
            if line.startswith('AppYCenter'):
                AppYCenter = float(line.split("=")[1].strip())
            if line.startswith('TextPath'):
                if '3' in line:
                    self.device = '3000'
                elif '4' in line:
                    self.device = '4000'
                else:
                    self.device = 'Unknown'

        if self.device == '4000':
            self.CameraHRatio = CameraVRatio
            self.CameraVRatio = CameraHRatio
            self.AppXCenter = AppYCenter
            self.AppYCenter = AppXCenter
        else:
            self.CameraHRatio = CameraHRatio
            self.CameraVRatio = CameraVRatio
            self.AppXCenter = AppXCenter
            self.AppYCenter = AppYCenter

class Output:
    '''
    The Output class will create an object that contains the information
    held in the output.txt file generated by the LOGOS software when
    capturing images
    '''
    def __init__(self, image_dir):
        textfile = os.path.join(os.path.dirname(image_dir),
                                  'output.txt')
        file = open(textfile, 'r')
        full_data = []
        for line in file:
            full_data.append([x.lstrip().rstrip() for x in line.split(',')])
            if line.startswith('Beamspots found'):
                no_of_spots = int(line.split(',')[-1])

        self.full_data = full_data
        date = full_data[0][3]
        self.datetime = datetime.datetime.strptime(date, '%H:%M:%S %m/%d/%Y')
        self.center = [float(full_data[0][5]),float(full_data[0][6])]
        if self.center[0] > 700 or self.center[1] > 700:
            self.device = "4000"
            # loc_name = list(pred_xrv4000.keys())
        else:
            self.device = "3000"
            # loc_name = list(pred_xrv3000.keys())
        self.no_of_spots = no_of_spots
        self.spots_xy = {}
        self.spots_width = {}
        self.spots_height = {}
        self.spots_diameter = {}
        self.spots_quality = {}

        for i in np.arange(1, 1 + self.no_of_spots):
            row = [full_data.index(x) for x in full_data if x[0] == str(i)][0]
            self.spots_xy[i] = [full_data[row][3],full_data[row][4]]
            self.spots_width[i] = full_data[row][19]
            self.spots_height[i] = full_data[row][23]
            self.spots_diameter[i] = full_data[row][25] # averaged diameter for every 5 degree
            self.spots_quality[i] = full_data[row][27]

class Profile:
    # def __init__(self, profile):
    #     self.lgrad, self.rgrad = spf.gradient_fetch(profile, 0.2, 0.8)
    #     self.fwhm = spf.fwhm_fetch(profile)
    def __init__(self, horporf):

        arr_mm = horporf[0]
        nor_amp = horporf[1]
        raw_amp = horporf[2]
        self.lgrad, self.rgrad, self.fwhm = spf.fetch_parameters(arr_mm, nor_amp, raw_amp)

    def __str__(self):
        return f'lgrad: {self.lgrad}, rgrad: {self.rgrad}, fwhm: {self.fwhm}'

class Spot:
    '''Defines an individual spot (from an array) and it's relevant properties
    as obtained from a LOGOS detector with an activescript.txt file
    '''
    def __init__(self, spot_array, pixel_loc, activescript):

        self.pixel_loc = pixel_loc
        horprof, vertprof, tl_br, bl_tr = spf.spot_to_profiles(spot_array, pixel_loc, activescript)

        # debug the gradient ratio
        # -----------------------------------------------
        # get the profile
        self.horprof_p = list(horprof)
        self.vertprof_p = list(vertprof)
        self.tl_br_p = list(tl_br)
        self.bl_tr_p = list(bl_tr)
        # -----------------------------------------------

        self.horprof = Profile(horprof)
        self.vertprof = Profile(vertprof)
        self.tl_br = Profile(tl_br)
        self.bl_tr = Profile(bl_tr)

        x = self.pixel_loc[0] - activescript.AppXCenter
        y = self.pixel_loc[1] - activescript.AppYCenter
        x = x / activescript.CameraHRatio
        y = y / activescript.CameraVRatio

        self.rel_pixel_loc = [x, y]

    def __str__(self):
        return f'horprof: {self.horprof}\nvertprof: {self.vertprof}\n'\
               f'tl_br: {self.tl_br}\n bl_tr: {self.bl_tr}\n'\
               f'pixel_loc: {self.pixel_loc}\n'\
               f'rel_pixel_loc: {self.rel_pixel_loc}\n'

    def list_results(self):
        result = [self.rel_pixel_loc[0], self.rel_pixel_loc[1],
                  self.horprof.lgrad, self.horprof.rgrad, self.horprof.fwhm,
                  self.vertprof.lgrad, self.vertprof.rgrad, self.vertprof.fwhm,
                  self.bl_tr.lgrad, self.bl_tr.rgrad, self.bl_tr.fwhm,
                  self.tl_br.lgrad, self.tl_br.rgrad, self.tl_br.fwhm]
        result = [float(i) for i in result]
        return result

class SpotPattern:
    '''Class to define spot pattern images acquired using the flat LOGOS panels
    '''
    def __init__(self, image_path):
        if not os.path.isfile(image_path):
            print('No image selected, code will terminate')
            input('Press any key to continue')
            raise SystemExit

        image_dir = os.path.dirname(image_path) # the directory to get the image

        if not os.path.isfile(os.path.join(image_dir, 'activescript.txt')):
            print('No active script detected for this spot pattern')
            input('Press any key to continue')
            raise SystemExit



        self.path = image_path
        self.activescriptpath = os.path.join(image_dir, 'activescript.txt')
        self.activescript = ActiveScript(self.activescriptpath)
        self.outputpath = os.path.join(image_dir, 'output.txt')
        self.output = Output(self.outputpath)
        self.image = cv2.imread(image_path)
        self.range = 60

        if self.activescript.device == '4000':
            self.image = cv2.rotate(self.image, cv2.ROTATE_90_COUNTERCLOCKWISE)

        # self.rot_l, self.rot_s = self.flip_ls()
        self.mloc, self.match = self.identify_spot() # corrlate the position name with the key in spots_xy

        spot_info = {key:0 for key, val in self.mloc.items() if val[0] !=0}
        # if self.device == "4000":
        for key in spot_info.keys():
            # update spots_xy, spots_width(was spots_height), spot_height(was spots_width), spot_diameter, spots_quality
            spot_info[key] = copy.deepcopy(self.mloc[key])
            spot_info[key].append(self.output.spots_height[self.match[key]])
            spot_info[key].append(self.output.spots_width[self.match[key]])
            spot_info[key].append(self.output.spots_diameter[self.match[key]])
            spot_info[key].append(self.output.spots_quality[self.match[key]])

        self.spots_info = spot_info

        self.pixel_loc = self.find_bmp_spot(image_path)
        self.spot_arr = self.find_bmp_spot_arr()

        spt = {key: 0  for key in self.spot_arr.keys()}
        for s in self.spot_arr.keys():
            # print(f'-----------------------')
            # print(f'>>>spot location : {s}')
            # print(f'-----------------------')
            spt[s] = Spot(self.spot_arr[s], self.pixel_loc[s], self.activescript)

        self.spot = spt



    def find_bmp_spot(self, image_path):
        mloc = self.mloc

        if self.activescript.device == "4000":
            npixel_y = 1600
            npixel_x = 1200
            resol_x = self.activescript.CameraHRatio
            resol_y = self.activescript.CameraVRatio


        elif self.activescript.device == "3000":
            npixel_y = 1200
            npixel_x = 1200
            resol_x = self.activescript.CameraHRatio
            resol_y = self.activescript.CameraVRatio

        # ## convert the x-y axes from pixel to image coordinates
        # ### logos mechanical centre in pixel
        x_lmcp = self.activescript.AppXCenter
        y_lmcp = self.activescript.AppYCenter

        x_mm = [((i/resol_x) - (x_lmcp/resol_x)) for i in range(1, npixel_x+1)]
        y_mm = [((i/resol_y) - (y_lmcp/resol_y)) for i in range(1, npixel_y+1)]

        # # ## find the pixel coordinate of each spot from the bmp image
        pixel_loc = {key:[round((arr[0]*resol_x) + x_lmcp) , round((arr[1]*resol_y) + y_lmcp) ] for key, arr in mloc.items()}

        return pixel_loc

    def find_bmp_spot_arr(self):
        single_slice = self.image[:, :, 0]
        d = self.range

        spot_arr = {key:[0] for key in self.mloc.keys()}
        for key in self.mloc.keys():
            spot_arr[key] = single_slice[self.pixel_loc[key][1]- d: self.pixel_loc[key][1]+d+1 , self.pixel_loc[key][0]-d:self.pixel_loc[key][0]+d+1 ]

        return spot_arr

        # self.rot_l, self.rot_s = self.flip_ls()
        self.mloc, self.match = self.identify_spot() # corrlate the position name with the key in spots_xy

        spot_info = {key:0 for key, val in self.mloc.items() if val[0] !=0}
        # if self.device == "4000":
        for key in spot_info.keys():
            # update spots_xy, spots_width(was spots_height), spot_height(was spots_width), spot_diameter, spots_quality
            spot_info[key] = copy.deepcopy(self.mloc[key])
            spot_info[key].append(self.spots_height[self.match[key]])
            spot_info[key].append(self.spots_width[self.match[key]])
            spot_info[key].append(self.spots_diameter[self.match[key]])
            spot_info[key].append(self.spots_quality[self.match[key]])

        self.spots_info = spot_info

    def identify_spot(self):
        pred_xrv4000 = cs.pred_xrv4000
        pred_xrv3000 = cs.pred_xrv3000

        if self.output.device == "4000":
            loc_name = list(pred_xrv4000.keys())
            ploc = pred_xrv4000
            flip_factor = -1 # flip the long axis coordinates while transfering to the image coordinates from Callum's code

        elif self.output.device == "3000":
            loc_name = list(pred_xrv3000.keys())
            ploc = pred_xrv3000
            flip_factor = 1

        # create an empty dictionary with the position name as the key
        mloc = {key:[0,0] for key in loc_name}

        match = {key:0 for key in loc_name}
        for key, item in self.output.spots_xy.items():
            for pkey, pitem in ploc.items():
                tol = 10
                # negative sign was added in front of y-coordinate of the spot position because the logos output coordinates need to match with the image coordinates
                if self.output.device == "4000":
                    if float(item[1]) > float(pitem[0] -tol) and float(item[1]) < float(pitem[0] +tol): # find the spot with matching long axis coordinate
                        if flip_factor*float(item[0]) > float(pitem[1] -tol) and flip_factor*float(item[0]) < float(pitem[1] +tol): # find the spot with matching y-coordinate
                            mloc[pkey] =[float(item[1]), flip_factor*float(item[0])]
                            match[pkey] = key
                elif self.output.device == "3000":
                    if float(item[0]) > float(pitem[0] -tol) and float(item[0]) < float(pitem[0] +tol): # find the spot with matching long axis coordinate
                        if flip_factor*float(item[1]) > float(pitem[1] -tol) and flip_factor*float(item[1]) < float(pitem[1] +tol): # find the spot with matching y-coordinate
                            mloc[pkey] =[float(item[0]), flip_factor*float(item[1])]
                            match[pkey] = key

        for key, item in mloc.items():
            if item[0] == 0:
                if item[1] == 0:
                    print(f' >>>>> The script does not find any {key} spot! ')

        return mloc, match


    def __str__(self):
        return f'path: {self.path}\nact_scr_path: {self.activescriptpath}'
