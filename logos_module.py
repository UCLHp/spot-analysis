import numpy as np
from PIL import Image
import datetime
from astropy.modeling import models


class ActiveScript:
    '''
    The ActiveScript class will create an object that contains the information
    held in the activescript.txt file generated by the LOGOS software when
    capturing images
    '''
    def __init__(self, textfile):
        file = open(textfile, 'r')
        fulldata = []
        for line in file:
            fulldata.append((line.rstrip().lstrip()))
            if line.startswith('CameraHRa'):
                CameraHRatio = float(line[15:])
            if line.startswith('CameraVRa'):
                CameraVRatio = float(line[15:])
        self.CameraHRatio = CameraHRatio
        self.CameraVRatio = CameraVRatio


class Output:
    '''
    The Output class will create an object that contains the information
    held in the output.txt file generated by the LOGOS software when
    capturing images
    '''
    def __init__(self, textfile):
        file = open(textfile, 'r')
        full_data = []
        for line in file:
            full_data.append([x.lstrip().rstrip() for x in line.split(',')])
            if line.startswith('Beamspots found'):
                no_of_spots = int(line[18:])
        self.full_data = full_data
        date = full_data[0][3]
        self.datetime = datetime.datetime.strptime(date, '%H:%M:%S %m/%d/%Y')
        self.center = [float(full_data[0][5]),float(full_data[0][6])]
        self.no_of_spots = int(full_data[2][1])
        self.spots_xy = {}
        self.spots_width = {}
        self.spots_height = {}
        self.spots_diameter = {}
        self.spots_quality = {}
        for i in range(1, 1+self.no_of_spots):
            row = [full_data.index(x) for x in full_data if x[0] == str(i)][0]
            self.spots_xy[i] = [full_data[row][3],full_data[row][4]]
            self.spots_width[i] = full_data[row][19]
            self.spots_height[i] = full_data[row][23]
            self.spots_diameter[i] = full_data[row][25]
            self.spots_quality[i] = full_data[row][27]


def image_to_array(my_file, norm=False):
    '''
    Takes a file path as an input and reads it using the PIL Image library and
    then returns the data as a numpy array.
    Will normalise the array to a maximum of 1 if norm set to True
    '''
    my_image = Image.open(my_file)  # Image is a class within the PIL library
    my_array = np.array(my_image)
    if norm:
        my_array = np.true_divide(my_array, np.amax(my_array))
    return my_array


def csv_to_array(filename):
    """Return image numpy array of image plus pitch (pixel size)
    """

    spotdata = open(filename).readlines()

    # Image pitch (pixel width) is in first line
    pitch = float(spotdata[0].split("Pitch:,")[1].split(",")[0].strip())

     # 3rd line contains image dimension - ALWAYS??      ##TODO: CHECK CORRECT FOR NON-SQUARE IMAGES
    nrows = int( spotdata[2].split(",")[1].strip() )    # or is this x dim => no. columns?
    ncols = int( spotdata[2].split(",")[2].strip() )    #            y dim => no. rows?

    spotimage = np.zeros( [nrows,ncols] )   ## format np([rows,cols])

    for row in range(3, nrows+3): # Image data starts on fourth row
        spotimage[row-3] = np.array( spotdata[row].split(",") ).astype(float)

    return spotimage  # , pitch


def find_centre(my_array, *, threshold=0.9,  norm=True):
    '''
    Takes a numpy array as input and uses the threshold to make a binary image
    the upper/lowermost, left/rightmost pixels are used to find center pixel
    based on a normalised array by default but can use absolute image values
    '''
    if norm:
        my_array = np.true_divide(my_array, np.amax(my_array))
    my_array = my_array.astype(np.float)  # np.true_divide(my_array, 1)
    above_thresh = np.where(my_array > threshold)
    CentreRow = int((max(above_thresh[0])+min(above_thresh[0]))/2)
    CentreCol = int((max(above_thresh[1])+min(above_thresh[1]))/2)
    return [CentreRow, CentreCol]


def central_xy_profiles(array, center, resolution=[1, 1]):
    '''
    Returns 'x' 'y' profiles of an array at the index defined by 'centre'
    these profiles are centred at 0 and distances are absolute
    '''
    x = np.asarray(range(0, array.shape[1]))
    y = np.asarray(range(0, array.shape[0]))
    centered_x = (x - center[1])/resolution[0]
    centered_y = (y - center[0])/resolution[1]

    XProfile = np.asarray([centered_x, array[center[0]]])
    YProfile = np.asarray([centered_y, array[:, center[1]]])

    return XProfile, YProfile


def crop_center(img, cropx, cropy):
    y, x = img.shape
    startx = x//2-(cropx//2)
    starty = y//2-(cropy//2)
    return img[starty:starty+cropy, startx:startx+cropx]

# No longer required as Double Gaussian taken from astropy library with offset
@models.custom_model
def twoD_Gaussian(x, y, A=1, x_mean=0, y_mean=0, theta=0, sigma_x1=1, sigma_y1=1, B=0, sigma_x2=1, sigma_y2=1, offset=0):
    '''
    Equation to calculate two overlapping 2-Dimensional point spread functions
    Both PSFs have the same centre and degree of rotation for simplicity
    but have a major and minor sigma and different amplitudes
    '''

    x_mean = float(x_mean) #x_mean and y_mean are the offsets for the central point of the gaussian
    y_mean = float(y_mean) #I have assumed it is the same for both the primary and scatter beam
    a = (np.cos(theta)**2)/(2*sigma_x1**2) + (np.sin(theta)**2)/(2*sigma_y1**2) #a,b,c,d,e and f are taken from the generalised gaussian equation and use theta to rotate the curves in 2D. sigma represents the width of each curve
    b = -(np.sin(2*theta))/(4*sigma_x1**2) + (np.sin(2*theta))/(4*sigma_y1**2)
    c = (np.sin(theta)**2)/(2*sigma_x1**2) + (np.cos(theta)**2)/(2*sigma_y1**2)
    d = (np.cos(theta)**2)/(2*sigma_x2**2) + (np.sin(theta)**2)/(2*sigma_y2**2)
    e = -(np.sin(2*theta))/(4*sigma_x2**2) + (np.sin(2*theta))/(4*sigma_y2**2)
    f = (np.sin(theta)**2)/(2*sigma_x2**2) + (np.cos(theta)**2)/(2*sigma_y2**2)
    # g = offset + A*np.exp(-(a*((x-x_mean)**2) + 2*b*(x-x_mean)*(y-y_mean) + c*((y-y_mean)**2))) + A*B*np.exp(-(d*((x-x_mean)**2) + 2*e*(x-x_mean)*(y-y_mean) + f*((y-y_mean)**2)))
    #g is the result of the fit as one long list
    return offset + A*np.exp(-(a*((x-x_mean)**2) + 2*b*(x-x_mean)*(y-y_mean) + c*((y-y_mean)**2))) + B*np.exp(-(d*((x-x_mean)**2) + 2*e*(x-x_mean)*(y-y_mean) + f*((y-y_mean)**2)))


# No longer required as Double Gaussian taken from astropy library with offset
@models.custom_model
def PSF(x, y, A=1, xo1=0, yo1=0, theta=0, sigma_x1=1, sigma_y1=1, offset=0):
    '''
    Equation to calculate two overlapping 2-Dimensional point spread functions
    Both PSFs have the same centre and degree of rotation for simplicity
    but have a major and minor sigma and different amplitudes
    '''

    xo1 = float(xo1) #xo1 and yo1 are the offsets for the central point of the gaussian
    yo1 = float(yo1) #I have assumed it is the same for both the primary and scatter beam
    a = (np.cos(theta)**2)/(2*sigma_x1**2) + (np.sin(theta)**2)/(2*sigma_y1**2) #a,b,c,d,e and f are taken from the generalised gaussian equation and use theta to rotate the curves in 2D. sigma represents the width of each curve
    b = -(np.sin(2*theta))/(4*sigma_x1**2) + (np.sin(2*theta))/(4*sigma_y1**2)
    c = (np.sin(theta)**2)/(2*sigma_x1**2) + (np.cos(theta)**2)/(2*sigma_y1**2)
    # g = offset + A*np.exp(-(a*((x-xo1)**2) + 2*b*(x-xo1)*(y-yo1) + c*((y-yo1)**2))) + A*B*np.exp(-(d*((x-xo1)**2) + 2*e*(x-xo1)*(y-yo1) + f*((y-yo1)**2)))
    # g is the result of the fit as one long list
    return offset + A*np.exp(-(a*((x-xo1)**2) + 2*b*(x-xo1)*(y-yo1) + c*((y-yo1)**2)))


def uniformity_ROI(uniformity_array, threshold=0.5):
    '''Returns central region of rectangular field and image for reference

            Parameters:
                uniformity_array(numpy): greyscale uniformity image as np array
                threshold(float): where to threshold the image to delect ROI

            Returns:
                ROI_display(matplotlib): image to confirm ROI on original image
                uniformity(float): central region uniformity metric
                                   calculated by ~ 100*(max-min)/(max+min)
    '''
    area_above_thresh = np.where(uniformity_array > threshold)

    width = max(area_above_thresh[1]) - min(area_above_thresh[1])
    height = max(area_above_thresh[0]) - min(area_above_thresh[0])

    left80 = int(min(area_above_thresh[0]) + 0.1 * width)
    right80 = int(min(area_above_thresh[0]) + 0.9 * width)
    top80 = int(min(area_above_thresh[1]) + 0.1 * height)
    bottom80 = int(min(area_above_thresh[1]) + 0.9 * height)

    ROI_display = np.copy(uniformity_array)
    ROI_display[top80, left80:right80] = 0
    ROI_display[bottom80, left80:right80] = 0
    ROI_display[top80:bottom80, left80] = 0
    ROI_display[top80:bottom80, right80] = 0

    ROI = uniformity_array[top80:bottom80, left80:right80]
    return ROI, ROI_display

# Functions no longer used.
#
#
#
#
# #######################
# #Collection of functions used in other code for the analysis of spot profiles
# #######################
# from scipy.optimize import curve_fit
#
# def ReadLOGOS(filename):
#     FullFile=list(reader(open(filename)))
#     Pitch = float(FullFile[0][4])
#     Size = int(FullFile[4][2])
#     Data = FullFile[5:(Size+6)]
#     return(FullFile,Data,Pitch)
#
#
# def rotateImage(array, angle, pivot): #Function to rotate an array a given angle around a defined axis
#     padX = [array.shape[1] - pivot[0], pivot[0]] #Creates 0's on the X axis such that the pivot is at the centre of the array
#     padY = [array.shape[0] - pivot[1], pivot[1]] #Creates 0's on the Y axis such that the pivot is at the centre of the array
#     arrayP = np.pad(array, [padY, padX], 'constant') #Adds padding to the array
#     arrayR = ndimage.rotate(arrayP, angle, reshape=False) #Rotates the array around it's centre
#     return arrayR[padY[0] : -padY[1], padX[0] : -padX[1]] #Removes the previously added padding and returns the result
#     #further info here: https://stackoverflow.com/questions/25458442/rotate-a-2d-image-around-specified-origin-in-python
#
#
# def FileNameToSpotPosition(Energyfilename, Params):
#     original = cv2.imread(Energyfilename) # Creates a variable for the image file as an array
#     gray = cv2.cvtColor(original, cv2.COLOR_BGR2GRAY) # Ensures the image is in grayscale
#     blurred = cv2.GaussianBlur(gray, (51, 51), 0, cv2.BORDER_ISOLATED) # blurring the image is better for the thresholding, 51 is the size of the kernel
#     thresholded = cv2.threshold(blurred, Params['Threshold'].item(), 255, cv2.THRESH_BINARY)[1]
#     eroded = cv2.erode(thresholded, None, iterations=2)
#     dilated = cv2.dilate(eroded, None, iterations=2)
#     circles = cv2.HoughCircles(dilated, cv2.HOUGH_GRADIENT, 1, Params['Min Distance Between Spots'].item(), param1=50, param2=Params['Specificity'].item(), minRadius=0, maxRadius=int(Params['Max Detection Size'].item()))
#     circles = np.round(circles[0, :]).astype("int")
#     SpotPosns = np.delete(circles,2,axis=1)
#     order = np.round(SpotPosns,decimals=-2)
#     sort=np.lexsort((order[:,0],order[:,1]))
#     SpotPosns = SpotPosns[sort]
#     return(SpotPosns)
