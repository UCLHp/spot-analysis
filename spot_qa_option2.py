import os
import datetime

import easygui as eg
import pypyodbc
import matplotlib.pyplot as plt

import logos_module as lm
# import test.test_version

class Output:
    '''
    The Output class will create an object that contains the information
    held in the output.txt file generated by the LOGOS software when
    capturing images
    '''
    def __init__(self, textfile):
        file = open(textfile, 'r')
        full_data = []
        for line in file:
            full_data.append([x.lstrip().rstrip() for x in line.split(',')])
            if line.startswith('Beamspots found'):
                no_of_spots = int(line[18:])

        self.full_data = full_data
        date = full_data[0][3]
        self.datetime = datetime.datetime.strptime(date, '%H:%M:%S %m/%d/%Y')
        self.center = [float(full_data[0][5]),float(full_data[0][6])]
        self.no_of_spots = no_of_spots
        self.spots_xy = {}
        self.spots_width = {}
        self.spots_height = {}
        self.spots_diameter = {}
        self.spots_quality = {}
        for i in range(1, 1+self.no_of_spots):
            row = [full_data.index(x) for x in full_data if x[0] == str(i)][0]
            self.spots_xy[i] = [full_data[row][3],full_data[row][4]]
            self.spots_width[i] = full_data[row][19]
            self.spots_height[i] = full_data[row][23]
            self.spots_diameter[i] = full_data[row][25]
            self.spots_quality[i] = full_data[row][27]

def find_circles(image_array):


DATABASE_DIR = 'O:\\protons\\Work in Progress\\Callum\\AccessDatabase\\AssetsDatabase_beCG.accdb'
pswrd=''
conn = pypyodbc.connect(
            'Driver={Microsoft Access Driver (*.mdb, *.accdb)};'
            'DBQ=' + DATABASE_DIR + ';'
            + pswrd
            )
cursor = conn.cursor()

# Produce list of energies for multchoicebox - could be linked to Database?
energy_options = [x for x in list(range(70, 245, 5))+[244]]

# Select acquired energies
energies = eg.multchoicebox('Select Energies',
                            'Please select the energies that '
                            'have spot pattern image files', energy_options
                            )
energies = sorted([int(i) for i in energies], reverse=True)
print(f'Energies acquired: {energies}\n')

# Select Operator from list in Database
cursor.execute('select * from [Operators]')
operators = [row[2] for row in cursor.fetchall()]
operator = eg.choicebox('Who performed the measurements?',
                        'Operator',
                        operators)
if not operator:
    eg.msgbox('Please re-run the code and select an Operator')
    raise SystemExit
print(f'Operator = {operator}\n')

# Select Gantry from list in Database
cursor.execute("select [MachineName] from [Machines] where [MachineType] = 'Gantry'")
machines = [row[0] for row in cursor.fetchall()]
gantry = eg.choicebox('Which room were the measurements performed in?',
                      'Gantry',
                      machines)
if not gantry:
    eg.msgbox('Please re-run the code and select a room')
    raise SystemExit
print(f'Gantry = {gantry}\n')

# User selects directory containing all acquired spot grid energies
mydir = eg.diropenbox('Select Folders Containing Acquired Images '
                    'For All Acquired Energies')

# Check directory has been selected
if not mydir:
    eg.msgbox('Please re-run the code and select a folder containing the data'
              ' to be analysed', title='Folder Selection Error')
    raise SystemExit

# Check to ensure number of energies defined matches the number of images
if not len(energies) == len(os.listdir(mydir)):
    eg.msgbox('Number of files in directory does not match number of Energies '
    'selected\nPlease re-run the program', 'File Count Error')
    raise SystemExit

# Loop to populate output and image dictionary from LOGOS output files
spot_properties = {}
image_arrays = {}
count = 0
for foldername in sorted(os.listdir(mydir)):
    # Check active script is present
    if not os.path.isfile(os.path.join(os.path.join(mydir, foldername),
                                       'activescript.txt')):
        eg.msgbox(f"Folder {foldername} Doesn't contain the activescript "
                  "file required to calculate the image resolution")
        raise SystemExit
    # Check output file is present
    if not os.path.isfile(os.path.join(os.path.join(mydir, foldername),
                                       'output.txt')):
        eg.msgbox(f"Folder {foldername} Doesn't contain the output file "
                  "required for the spot data")
        raise SystemExit
    # Distinguish between tif and bmp files
    for i in os.listdir(os.path.join(mydir,foldername)):
        if i.endswith('tif'):
            filename = '00000001.tif'
            break
        if i.endswith('bmp'):
            filename = '00000001.bmp'
            break
    if not filename:
        input('No image file detected')
        raise SystemExit
    output = os.path.join(os.path.join(mydir, foldername), 'output.txt')
    gridimage = os.path.join(os.path.join(mydir, foldername), filename)
    activescript = lm.fetch_pixel_dimensions(gridimage)
    spot_properties[energies[count]] = Output(output)
    image_arrays[energies[count]] = lm.image_to_array(gridimage)
    count+=1

###############################################################################
# Print Results - will input to DB once table is created
###############################################################################

print(f'Operator was {operator}\n')
print(f'Images acquired on {gantry}\n')
for x in energies:
    print(f"Results for {x}MeV Spots:\n")
    print('Center:')
    print(spot_properties[x].center)
    print('Spot Positions:')
    print(spot_properties[x].spots_xy)
    print('Spot Width:')
    print(spot_properties[x].spots_width)
    print('Spot Height:')
    print(spot_properties[x].spots_height)
    print('Averaged Spot Diameter:')
    print(spot_properties[x].spots_diameter)
    print('Spot Circularity:')
    print(spot_properties[x].spots_quality)
    print()



cropped, maxpix = lm.cropspot(image_arrays[energies[0]], [440,200], 0.5, 2)


plt.imshow(cropped)
plt.show()
